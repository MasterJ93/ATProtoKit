{"identifier":{"url":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormatting-PropertyWrapper","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/ATProtoKit\/documentation\/ATProtoKit"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"type":"text","text":"Convert dates to and from the ISO8601 format."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"text":"AT Protocol requires that dates must be formatted in the ISO8601 format. ATProtoKit gives you the tools to convert from ","type":"text"},{"code":"Date","type":"codeVoice"},{"type":"text","text":" to ISO8601 formatted dates and vice versa with custom "},{"type":"codeVoice","code":"Decodable"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":" methods. All methods use "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/CustomDateFormatter"},{"text":" to do the decoding and encoding.","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The methods should be used over the "},{"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormatting","isActive":true,"type":"reference"},{"text":" and ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormattingOptional","type":"reference"},{"text":" property wrappers, which are now deprecated.","type":"text"}]}]},{"type":"heading","text":"Usage","anchor":"Usage","level":2},{"type":"paragraph","inlineContent":[{"text":"The easiest way to do this is by using the ","type":"text"},{"code":"@ATLexiconModel","type":"codeVoice"},{"type":"text","text":" macro:"}]},{"code":["@ATLexiconModel","public struct UserProfile: ATRecordProtocol {","    public static private(set) var type = \"com.example.actor.profile\"","    public let userID: Int","    public let username: String","    public var bio: String?","    public var avatarURL: URL?","    public var followerCount: Int?","    public var followingCount: Int?","    public let createdAt: Date","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This will automatically create the custom initializer, as well as the custom decoding initializer and encoding method, in order to insert the appropriate methods.","type":"text"}]},{"type":"heading","text":"Manual Entry","level":2,"anchor":"Manual-Entry"},{"inlineContent":[{"text":"If you rather write the custom initializers and methods manually, you can do so as well. When creating the custom initializers and methods, you’ll want to replace the following methods with the custom ones:","type":"text"}],"type":"paragraph"},{"alignments":["right","left"],"rows":[[[{"inlineContent":[{"text":"Replace","type":"text"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"With…","type":"text"}]}]],[[{"inlineContent":[{"code":"decode(_:forKey:)","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDate(forKey:)","isActive":true}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decodeIfPresent(_:forKey:)"}]}],[{"inlineContent":[{"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDateIfPresent(forKey:)","isActive":true,"type":"reference"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"encode(_:forKey:)"}],"type":"paragraph"}],[{"inlineContent":[{"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDate(_:forKey:)","isActive":true,"type":"reference"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"code":"encodeIfPresent(_:forKey:)","type":"codeVoice"}]}],[{"inlineContent":[{"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDateIfPresent(_:forKey:)","type":"reference","isActive":true}],"type":"paragraph"}]]],"header":"row","type":"table"},{"type":"codeListing","syntax":"swift","code":["public struct UserProfile: ATRecordProtocol {","    public static private(set) var type = \"com.example.actor.profile\"","    public let userID: Int","    public let username: String","    public var bio: String?","    public var avatarURL: URL?","    public var followerCount: Int?","    public var followingCount: Int?","    public let createdAt: Date","","    public init(userID: Int, username: String, bio: String? = nil, avatarURL: URL? = nil,","                followerCount: Int? = nil, followingCount: Int? = nil, createdAt: Date) {","        self.userID = userID","        self.username = username","        self.bio = bio","        self.avatarURL = avatarURL","        self.followerCount = followerCount","        self.followingCount = followingCount","        self.createdAt = createdAt","    }","","    public init(from decoder: any Decoder) throws {","        let container = try decoder.container(keyedBy: CodingKeys.self)","","        self.userID = try container.decode(Int.self, forKey: .userID)","        self.username = try container.decode(String.self, forKey: .username)","        self.bio = try container.decodeIfPresent(String.self, forKey: .bio)","        self.avatarURL = try container.decodeIfPresent(URL.self, forKey: .avatarURL)","        self.followerCount = try container.decodeIfPresent(Int.self, forKey: .followerCount)","        self.followingCount = try container.decodeIfPresent(Int.self, forKey: .followingCount)","        \/\/ Replace `container.decode(Date.self, forKey: .createAt)`.","        self.createdAt = try container.decodeDate(forKey: .createdAt)","    }","","    public func encode(to encoder: any Encoder) throws {","        var container = encoder.container(keyedBy: CodingKeys.self)","","        try container.encode(self.userID, forKey: .userID)","        try container.encode(self.username, forKey: .username)","        try container.encodeIfPresent(self.bio, forKey: .bio)","        try container.encodeIfPresent(self.avatarURL, forKey: .avatarURL)","        try container.encodeIfPresent(self.followerCount, forKey: .followerCount)","        try container.encodeIfPresent(self.followingCount, forKey: .followingCount)","        \/\/ Replace `container.encode(self.createdAt, forKey: .createdAt)`.","        try container.encodeDate(self.createdAt, forKey: .createdAt)","    }","","    enum CodingKeys: CodingKey {","        case userID","        case username","        case bio","        case avatarURL","        case followerCount","        case followingCount","        case createdAt","    }","}"]}]}],"kind":"article","topicSections":[{"identifiers":["doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/CustomDateFormatter"],"title":"CustomDateFormatter"},{"title":"Decodable Methods","identifiers":["doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDate(forKey:)","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDateIfPresent(forKey:)"]},{"identifiers":["doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDate(_:forKey:)","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDateIfPresent(_:forKey:)"],"title":"Encodable Methods"},{"title":"Deprecated Property Wrappers","identifiers":["doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormatting","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormattingOptional"]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/atprotokit\/dateformatting-propertywrapper"]}],"metadata":{"modules":[{"name":"ATProtoKit"}],"role":"collectionGroup","roleHeading":"API Collection","title":"Custom Date Encoding and Decoding","color":{"standardColorIdentifier":"blue"}},"sections":[],"seeAlsoSections":[{"title":"Utilities","generated":true,"identifiers":["doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ATProtoTools","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ATFacetParser","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/SessionDebuggableArticle","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/SessionDebuggable","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ConsoleDebugger","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Truncatable","doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/APIHostname"]}],"references":{"doc://ATProtoKit/documentation/ATProtoKit/DateFormatting":{"title":"DateFormatting","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"DateFormatting","kind":"identifier"}],"navigatorTitle":[{"text":"DateFormatting","kind":"identifier"}],"type":"topic","role":"symbol","deprecated":true,"abstract":[{"type":"text","text":"A property wrapper for encoding and decoding "},{"code":"Date","type":"codeVoice"},{"text":" objects with the ISO8601 format.","type":"text"}],"url":"\/documentation\/atprotokit\/dateformatting","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormatting"},"doc://ATProtoKit/documentation/ATProtoKit/SessionDebuggableArticle":{"url":"\/documentation\/atprotokit\/sessiondebuggablearticle","role":"article","title":"Inspecting JSON with SessionDebuggable","type":"topic","abstract":[{"text":"Learn how to inspect JSON objects in your requests and responses.","type":"text"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/SessionDebuggableArticle","kind":"article"},"doc://ATProtoKit/documentation/ATProtoKit/Swift/KeyedDecodingContainer/decodeDate(forKey:)":{"url":"\/documentation\/atprotokit\/swift\/keyeddecodingcontainer\/decodedate(forkey:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decodeDate","kind":"identifier"},{"kind":"text","text":"("},{"text":"forKey","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s22KeyedDecodingContainerV","text":"KeyedDecodingContainer"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"K"},{"text":">.","kind":"text"},{"text":"Key","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Date","kind":"typeIdentifier","preciseIdentifier":"s:10Foundation4DateV"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDate(forKey:)","title":"decodeDate(forKey:)","role":"symbol","abstract":[{"type":"text","text":"Decodes a non-optional date string using the provided "},{"type":"codeVoice","code":"CustomDateFormatter"},{"type":"text","text":"."}],"type":"topic","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"K"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"CodingKey"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://ATProtoKit/documentation/ATProtoKit/DateFormattingOptional":{"url":"\/documentation\/atprotokit\/dateformattingoptional","abstract":[{"type":"text","text":"A property wrapper for optionally encoding and decoding "},{"type":"codeVoice","code":"Date?"},{"type":"text","text":" objects with the"},{"type":"text","text":" "},{"text":"ISO8601 format.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DateFormattingOptional"}],"deprecated":true,"navigatorTitle":[{"kind":"identifier","text":"DateFormattingOptional"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/DateFormattingOptional","kind":"symbol","title":"DateFormattingOptional","role":"symbol"},"doc://ATProtoKit/documentation/ATProtoKit/ConsoleDebugger":{"url":"\/documentation\/atprotokit\/consoledebugger","role":"symbol","title":"ConsoleDebugger","type":"topic","navigatorTitle":[{"text":"ConsoleDebugger","kind":"identifier"}],"abstract":[{"text":"A default implementation of the ","type":"text"},{"code":"SessionDebuggable","type":"codeVoice"},{"type":"text","text":" protocol that logs requests and responses to"},{"text":" ","type":"text"},{"type":"text","text":"the console."}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"ConsoleDebugger","kind":"identifier"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ConsoleDebugger","kind":"symbol"},"doc://ATProtoKit/documentation/ATProtoKit/Swift/KeyedDecodingContainer/decodeDateIfPresent(forKey:)":{"url":"\/documentation\/atprotokit\/swift\/keyeddecodingcontainer\/decodedateifpresent(forkey:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"decodeDateIfPresent","kind":"identifier"},{"kind":"text","text":"("},{"text":"forKey","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s22KeyedDecodingContainerV","text":"KeyedDecodingContainer"},{"text":"<","kind":"text"},{"text":"K","kind":"typeIdentifier"},{"text":">.","kind":"text"},{"kind":"typeIdentifier","text":"Key"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Date","preciseIdentifier":"s:10Foundation4DateV"},{"kind":"text","text":"?"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedDecodingContainer\/decodeDateIfPresent(forKey:)","title":"decodeDateIfPresent(forKey:)","role":"symbol","abstract":[{"text":"Converts an ISO8601-formatted date string (if it exists) and converts it to a ","type":"text"},{"code":"Date?","type":"codeVoice"},{"type":"text","text":" object."}],"type":"topic","conformance":{"constraints":[{"code":"K","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"CodingKey","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://ATProtoKit/documentation/ATProtoKit/Swift/KeyedEncodingContainer/encodeDate(_:forKey:)":{"abstract":[{"type":"text","text":"Encodes a "},{"code":"Date","type":"codeVoice"},{"type":"text","text":" value to its string representation and converts it to its ISO8601 format."}],"role":"symbol","type":"topic","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDate(_:forKey:)","title":"encodeDate(_:forKey:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"encodeDate","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:10Foundation4DateV","text":"Date"},{"text":", ","kind":"text"},{"text":"forKey","kind":"externalParam"},{"kind":"text","text":": "},{"text":"KeyedEncodingContainer","kind":"typeIdentifier","preciseIdentifier":"s:s22KeyedEncodingContainerV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"K"},{"kind":"text","text":">."},{"text":"Key","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"}],"url":"\/documentation\/atprotokit\/swift\/keyedencodingcontainer\/encodedate(_:forkey:)","conformance":{"constraints":[{"code":"K","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"CodingKey","type":"codeVoice"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]}},"doc://ATProtoKit/documentation/ATProtoKit/Swift/KeyedEncodingContainer/encodeDateIfPresent(_:forKey:)":{"abstract":[{"type":"text","text":"Encodes a "},{"type":"codeVoice","code":"Date?"},{"type":"text","text":" value to its string representation (if the value exists) and converts it to"},{"type":"text","text":" "},{"text":"its ISO8601 format.","type":"text"}],"role":"symbol","type":"topic","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Swift\/KeyedEncodingContainer\/encodeDateIfPresent(_:forKey:)","title":"encodeDateIfPresent(_:forKey:)","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"encodeDateIfPresent"},{"text":"(","kind":"text"},{"text":"Date","preciseIdentifier":"s:10Foundation4DateV","kind":"typeIdentifier"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"forKey"},{"kind":"text","text":": "},{"text":"KeyedEncodingContainer","kind":"typeIdentifier","preciseIdentifier":"s:s22KeyedEncodingContainerV"},{"kind":"text","text":"<"},{"text":"K","kind":"typeIdentifier"},{"text":">.","kind":"text"},{"kind":"typeIdentifier","text":"Key"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"}],"url":"\/documentation\/atprotokit\/swift\/keyedencodingcontainer\/encodedateifpresent(_:forkey:)","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"K","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"CodingKey"},{"type":"text","text":"."}]}},"doc://ATProtoKit/documentation/ATProtoKit/ATFacetParser":{"kind":"symbol","abstract":[{"type":"text","text":"A utility class designed for parsing various elements like mentions, URLs, and hashtags from text."}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ATFacetParser","title":"ATFacetParser","navigatorTitle":[{"text":"ATFacetParser","kind":"identifier"}],"role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"ATFacetParser","kind":"identifier"}],"type":"topic","url":"\/documentation\/atprotokit\/atfacetparser"},"atprotokit_icon.png":{"identifier":"atprotokit_icon.png","type":"image","variants":[{"url":"\/images\/atprotokit_icon.png","traits":["1x","light"]}],"alt":"A technology icon representing the ATProtoKit framework."},"doc://ATProtoKit/documentation/ATProtoKit/APIHostname":{"title":"APIHostname","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/APIHostname","role":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"text":"APIHostname","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"APIHostname"}],"kind":"symbol","type":"topic","abstract":[{"text":"A list of hostnames used for the AT Protocol.","type":"text"}],"url":"\/documentation\/atprotokit\/apihostname"},"doc://ATProtoKit/documentation/ATProtoKit/SessionDebuggable":{"url":"\/documentation\/atprotokit\/sessiondebuggable","role":"symbol","title":"SessionDebuggable","type":"topic","navigatorTitle":[{"text":"SessionDebuggable","kind":"identifier"}],"abstract":[{"text":"A protocol for debugging and inspecting HTTP requests and responses within a network session.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SessionDebuggable"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/SessionDebuggable","kind":"symbol"},"doc://ATProtoKit/documentation/ATProtoKit":{"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit","images":[{"type":"icon","identifier":"atprotokit_icon.png"}],"abstract":[{"type":"text","text":"Develop and manage client and server-side applications for the AT Protocol and Bluesky."}],"url":"\/documentation\/atprotokit","kind":"symbol","type":"topic","role":"collection","title":"ATProtoKit"},"doc://ATProtoKit/documentation/ATProtoKit/Truncatable":{"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Truncatable","kind":"identifier"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/Truncatable","abstract":[{"type":"text","text":"A protocol that defines a method for truncating an object."}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"Truncatable","kind":"identifier"}],"type":"topic","title":"Truncatable","url":"\/documentation\/atprotokit\/truncatable"},"doc://ATProtoKit/documentation/ATProtoKit/ATProtoTools":{"title":"ATProtoTools","abstract":[{"type":"text","text":"A group of methods for miscellaneous aspects of ATProtoKit."}],"navigatorTitle":[{"kind":"identifier","text":"ATProtoTools"}],"identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/ATProtoTools","url":"\/documentation\/atprotokit\/atprototools","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ATProtoTools","kind":"identifier"}]},"doc://ATProtoKit/documentation/ATProtoKit/CustomDateFormatter":{"url":"\/documentation\/atprotokit\/customdateformatter","type":"topic","identifier":"doc:\/\/ATProtoKit\/documentation\/ATProtoKit\/CustomDateFormatter","abstract":[{"text":"A structure for custom date formatting to and from the ISO8601 format.","type":"text"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CustomDateFormatter"}],"navigatorTitle":[{"kind":"identifier","text":"CustomDateFormatter"}],"kind":"symbol","title":"CustomDateFormatter"}}}